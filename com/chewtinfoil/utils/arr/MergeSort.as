/** MergeSort by Ryan Matsikas. Feb 10, 2006*** Copyright (c) 2006 Ryan Matsikas* * Permission is hereby granted, free of charge, to any person* obtaining a copy of this software and associated documentation* files (the "Software"), to deal in the Software without* restriction, including without limitation the rights to use,* copy, modify, merge, publish, distribute, sublicense, and/or sell* copies of the Software, and to permit persons to whom the* Software is furnished to do so, subject to the following* conditions:* * The above copyright notice and this permission notice shall be* included in all copies or substantial portions of the Software.* * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR* OTHER DEALINGS IN THE SOFTWARE.*/package com.chewtinfoil.utils.arr {		import com.chewtinfoil.utils.ArrayUtils;	public class MergeSort {				public static function sort(p_arr:Array, ...args):void {						var low:uint = (args[0] == undefined) ? 0 : args[0];			var high:uint = (args[1] == undefined) ? p_arr.length-1 : args[1];						if (low == high) { return; }						var p:Number = (low+high) / 2 <<0;						sort(p_arr, low, p);			sort(p_arr, p+1, high);						var l:Number = high-low+1;						var working:Array = new Array(l);						for (var i:Number=0; i<l; i++) { working[i] = p_arr[low+i]; }						var m1:Number = 0;			var m2:Number = p-low+1;						for (var i:Number=0; i <l; i++) {				if (m2 <= high - low) {					if (m1 <= p - low) {						if (working[m1] > working[m2]) {							p_arr[i + low] = working[m2++];						} else {							p_arr[i + low] = working[m1++];						}					} else {						p_arr[i + low] = working[m2++];					}				} else {					p_arr[i + low] = working[m1++];				}			}		}			}}